<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - minecraft</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

			#oldie {
				background:rgb(100,0,0) !important;
				color:#fff !important;
				margin-top:10em !important;
			}
			#oldie a { color:#fff }

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - <a href="http://www.minecraft.net/" target="_blank">minecraft</a> demo. featuring <a href="http://painterlypack.net/" target="_blank">painterly pack</a><br />(left click: forward, right click: backward)</div>

		<script src="assets/js_libs/three.min.js"></script>

		<!--<script src="js/controls/FirstPersonControls.js"></script> -->
		<!-- <script src="js/Detector.js"></script> -->
		<script src="assets/js_libs/stats.js"></script>

		<script>

			// http://mrl.nyu.edu/~perlin/noise/

			var ImprovedNoise = function () {

				var p = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,
					 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,
					 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,
					 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,
					 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
					 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
					 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
					 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
					 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,
					 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];

				for (var i = 0; i < 256 ; i ++) {

					p[256 + i] = p[i];

				}

				function fade(t) {

					return t * t * t * (t * (t * 6 - 15) + 10);

				}

				function lerp(t, a, b) {

					return a + t * (b - a);

				}

				function grad(hash, x, y, z) {

					var h = hash & 15;
					var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
					return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);

				}

				return {

					noise: function (x, y, z) {

						var floorX = ~~x, floorY = ~~y, floorZ = ~~z;

						var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

						x -= floorX;
						y -= floorY;
						z -= floorZ;

						var xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;

						var u = fade(x), v = fade(y), w = fade(z);

						var A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;

						return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
										grad(p[BA], xMinus1, y, z)),
									lerp(u, grad(p[AB], x, yMinus1, z),
										grad(p[BB], xMinus1, yMinus1, z))),
								lerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1),
										grad(p[BA + 1], xMinus1, y, z - 1)),
									lerp(u, grad(p[AB + 1], x, yMinus1, zMinus1),
										grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));

					}
				}
			}

			/**
			 * @author mrdoob / http://mrdoob.com/
			 * @author alteredq / http://alteredqualia.com/
			 * @author paulirish / http://paulirish.com/
			 */

			THREE.FirstPersonControls = function ( object, domElement ) {

				this.object = object;
				this.target = new THREE.Vector3( 0, 0, 0 );

				this.domElement = ( domElement !== undefined ) ? domElement : document;

				this.enabled = true;

				this.movementSpeed = 1.0;
				this.lookSpeed = 0.005;

				this.lookVertical = true;
				this.autoForward = false;

				this.activeLook = true;

				this.heightSpeed = false;
				this.heightCoef = 1.0;
				this.heightMin = 0.0;
				this.heightMax = 1.0;

				this.constrainVertical = false;
				this.verticalMin = 0;
				this.verticalMax = Math.PI;

				this.autoSpeedFactor = 0.0;

				this.mouseX = 0;
				this.mouseY = 0;

				this.lat = 0;
				this.lon = 0;
				this.phi = 0;
				this.theta = 0;

				this.moveForward = false;
				this.moveBackward = false;
				this.moveLeft = false;
				this.moveRight = false;

				this.mouseDragOn = false;

				this.viewHalfX = 0;
				this.viewHalfY = 0;

				if ( this.domElement !== document ) {

					this.domElement.setAttribute( 'tabindex', -1 );

				}

				//

				this.handleResize = function () {

					if ( this.domElement === document ) {

						this.viewHalfX = window.innerWidth / 2;
						this.viewHalfY = window.innerHeight / 2;

					} else {

						this.viewHalfX = this.domElement.offsetWidth / 2;
						this.viewHalfY = this.domElement.offsetHeight / 2;

					}

				};

				this.onMouseDown = function ( event ) {

					if ( this.domElement !== document ) {

						this.domElement.focus();

					}

					event.preventDefault();
					event.stopPropagation();

					if ( this.activeLook ) {

						switch ( event.button ) {

							case 0: this.moveForward = true; break;
							case 2: this.moveBackward = true; break;

						}

					}

					this.mouseDragOn = true;

				};

				this.onMouseUp = function ( event ) {

					event.preventDefault();
					event.stopPropagation();

					if ( this.activeLook ) {

						switch ( event.button ) {

							case 0: this.moveForward = false; break;
							case 2: this.moveBackward = false; break;

						}

					}

					this.mouseDragOn = false;

				};

				this.onMouseMove = function ( event ) {

					if ( this.domElement === document ) {

						this.mouseX = event.pageX - this.viewHalfX;
						this.mouseY = event.pageY - this.viewHalfY;

					} else {

						this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
						this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;

					}

				};

				this.onKeyDown = function ( event ) {

					//event.preventDefault();

					switch ( event.keyCode ) {

						case 38: /*up*/
						case 87: /*W*/ this.moveForward = true; break;

						case 37: /*left*/
						case 65: /*A*/ this.moveLeft = true; break;

						case 40: /*down*/
						case 83: /*S*/ this.moveBackward = true; break;

						case 39: /*right*/
						case 68: /*D*/ this.moveRight = true; break;

						case 82: /*R*/ this.moveUp = true; break;
						case 70: /*F*/ this.moveDown = true; break;

					}

				};

				this.onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: /*up*/
						case 87: /*W*/ this.moveForward = false; break;

						case 37: /*left*/
						case 65: /*A*/ this.moveLeft = false; break;

						case 40: /*down*/
						case 83: /*S*/ this.moveBackward = false; break;

						case 39: /*right*/
						case 68: /*D*/ this.moveRight = false; break;

						case 82: /*R*/ this.moveUp = false; break;
						case 70: /*F*/ this.moveDown = false; break;

					}

				};

				this.update = function( delta ) {

					if ( this.enabled === false ) return;

					if ( this.heightSpeed ) {

						var y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );
						var heightDelta = y - this.heightMin;

						this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );

					} else {

						this.autoSpeedFactor = 0.0;

					}

					var actualMoveSpeed = delta * this.movementSpeed;

					if ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );
					if ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );

					if ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );
					if ( this.moveRight ) this.object.translateX( actualMoveSpeed );

					if ( this.moveUp ) this.object.translateY( actualMoveSpeed );
					if ( this.moveDown ) this.object.translateY( - actualMoveSpeed );

					var actualLookSpeed = delta * this.lookSpeed;

					if ( !this.activeLook ) {

						actualLookSpeed = 0;

					}

					var verticalLookRatio = 1;

					if ( this.constrainVertical ) {

						verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );

					}

					this.lon += this.mouseX * actualLookSpeed;
					if ( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;

					this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
					this.phi = THREE.Math.degToRad( 90 - this.lat );

					this.theta = THREE.Math.degToRad( this.lon );

					if ( this.constrainVertical ) {

						this.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );

					}

					var targetPosition = this.target,
						position = this.object.position;

					targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
					targetPosition.y = position.y + 100 * Math.cos( this.phi );
					targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );

					this.object.lookAt( targetPosition );

				};


				this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

				this.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );
				this.domElement.addEventListener( 'mousedown', bind( this, this.onMouseDown ), false );
				this.domElement.addEventListener( 'mouseup', bind( this, this.onMouseUp ), false );

				window.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );
				window.addEventListener( 'keyup', bind( this, this.onKeyUp ), false );

				function bind( scope, fn ) {

					return function () {

						fn.apply( scope, arguments );

					};

				};

				this.handleResize();

			};

			/**
			 * @author mrdoob / http://mrdoob.com/
			 */

			THREE.TypedGeometry = function ( size ) {

				THREE.BufferGeometry.call( this );

				if ( size !== undefined ) {

					this.setArrays(
						new Float32Array( size * 3 * 3 ),
						new Float32Array( size * 3 * 3 ),
						new Float32Array( size * 3 * 2 )
					);

				}

			};

			THREE.TypedGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
			THREE.TypedGeometry.prototype.constructor = THREE.TypedGeometry;

			THREE.TypedGeometry.prototype.setArrays = function ( vertices, normals, uvs ) {

				this.vertices = vertices;
				this.normals = normals;
				this.uvs = uvs;

				this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

				return this;

			};

			THREE.TypedGeometry.prototype.merge = ( function () {

				var offset = 0;
				var normalMatrix = new THREE.Matrix3();

				return function ( geometry, matrix, startOffset ) {

					if ( startOffset !== undefined ) offset = startOffset;

					var offset2 = offset * 2;
					var offset3 = offset * 3;

					var vertices = this.attributes.position.array;
					var normals = this.attributes.normal.array;
					var uvs = this.attributes.uv.array;

					if ( geometry instanceof THREE.TypedGeometry ) {

						var vertices2 = geometry.attributes.position.array;
						var normals2 = geometry.attributes.normal.array;
						var uvs2 = geometry.attributes.uv.array;

						for ( var i = 0, l = vertices2.length; i < l; i += 3 ) {

							vertices[ i + offset3     ] = vertices2[ i     ];
							vertices[ i + offset3 + 1 ] = vertices2[ i + 1 ];
							vertices[ i + offset3 + 2 ] = vertices2[ i + 2 ];

							normals[ i + offset3     ] = normals2[ i     ];
							normals[ i + offset3 + 1 ] = normals2[ i + 1 ];
							normals[ i + offset3 + 2 ] = normals2[ i + 2 ];

							uvs[ i + offset2     ] = uvs2[ i     ];
							uvs[ i + offset2 + 1 ] = uvs2[ i + 1 ];

						}

					} else if ( geometry instanceof THREE.IndexedTypedGeometry ) {

						var indices2 = geometry.attributes.index.array;
						var vertices2 = geometry.attributes.position.array;
						var normals2 = geometry.attributes.normal.array;
						var uvs2 = geometry.attributes.uv.array;

						for ( var i = 0, l = indices2.length; i < l; i ++ ) {

							var index = indices2[ i ];

							var index3 = index * 3;
							var i3 = i * 3;

							vertices[ i3 + offset3 ] = vertices2[ index3 ];
							vertices[ i3 + offset3 + 1 ] = vertices2[ index3 + 1 ];
							vertices[ i3 + offset3 + 2 ] = vertices2[ index3 + 2 ];

							normals[ i3 + offset3 ] = normals2[ index3 ];
							normals[ i3 + offset3 + 1 ] = normals2[ index3 + 1 ];
							normals[ i3 + offset3 + 2 ] = normals2[ index3 + 2 ];

							var index2 = index * 2;
							var i2 = i * 2;

							uvs[ i2 + offset2 ] = uvs2[ index2 ];
							uvs[ i2 + offset2 + 1 ] = uvs2[ index2 + 1 ];

						}

						if ( matrix !== undefined ) {

							matrix.applyToVector3Array( vertices, offset3, indices2.length * 3 );

							normalMatrix.getNormalMatrix( matrix );
							normalMatrix.applyToVector3Array( normals, offset3, indices2.length * 3 );

						}

						offset += indices2.length;

					}

				};

			} )();

			/**
			 * @author mrdoob / http://mrdoob.com/
			 */

			THREE.IndexedTypedGeometry = function () {

				THREE.BufferGeometry.call( this );

			};

			THREE.IndexedTypedGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
			THREE.IndexedTypedGeometry.prototype.constructor = THREE.IndexedTypedGeometry;

			THREE.IndexedTypedGeometry.prototype.setArrays = function ( indices, vertices, normals, uvs ) {

				this.indices = indices;
				this.vertices = vertices;
				this.normals = normals;
				this.uvs = uvs;

				this.attributes[ 'index' ] = { array: indices, itemSize: 1 };
				this.attributes[ 'position' ] = { array: vertices, itemSize: 3 };
				this.attributes[ 'normal' ] = { array: normals, itemSize: 3 };
				this.attributes[ 'uv' ] = { array: uvs, itemSize: 2 };

				return this;

			};

			/**
			 * @author mrdoob / http://mrdoob.com/
			 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
			 */

			THREE.PlaneTypedGeometry = function ( width, height, widthSegments, heightSegments ) {

				this.parameters = {
					width: width,
					height: height,
					widthSegments: widthSegments,
					heightSegments: heightSegments
				};

				var width_half = width / 2;
				var height_half = height / 2;

				var gridX = widthSegments || 1;
				var gridY = heightSegments || 1;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var segment_width = width / gridX;
				var segment_height = height / gridY;

				var vertices = new Float32Array( gridX1 * gridY1 * 3 );
				var normals = new Float32Array( gridX1 * gridY1 * 3 );
				var uvs = new Float32Array( gridX1 * gridY1 * 2 );

				var offset = 0;
				var offset2 = 0;

				for ( var iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segment_height - height_half;

					for ( var ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segment_width - width_half;

						vertices[ offset     ] = x;
						vertices[ offset + 1 ] = - y;

						normals[ offset + 2 ] = 1;

						uvs[ offset2     ] = ix / gridX;
						uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

						offset += 3;
						offset2 += 2;

					}

				}

				offset = 0;

				var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

				for ( var iy = 0; iy < gridY; iy ++ ) {

					for ( var ix = 0; ix < gridX; ix ++ ) {

						var a = ix + gridX1 * iy;
						var b = ix + gridX1 * ( iy + 1 );
						var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = ( ix + 1 ) + gridX1 * iy;

						indices[ offset     ] = a;
						indices[ offset + 1 ] = b;
						indices[ offset + 2 ] = d;

						indices[ offset + 3 ] = b;
						indices[ offset + 4 ] = c;
						indices[ offset + 5 ] = d;

						offset += 6;

					}

				}

				THREE.IndexedTypedGeometry.call( this );

				this.setArrays( indices, vertices, normals, uvs );
				this.computeBoundingSphere();

			};

			THREE.PlaneTypedGeometry.prototype = Object.create( THREE.IndexedTypedGeometry.prototype );
			THREE.PlaneTypedGeometry.prototype.constructor = THREE.PlaneTypedGeometry;

			var container, stats;

			var camera, controls, scene, renderer;

			var mesh;

			var worldWidth = 128, worldDepth = 128,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2,
			data = generateHeight( worldWidth, worldDepth );

			var clock = new THREE.Clock();

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
				camera.position.y = getY( worldHalfWidth, worldHalfDepth ) * 100 + 100;

				controls = new THREE.FirstPersonControls( camera );

				controls.movementSpeed = 1000;
				controls.lookSpeed = 0.125;
				controls.lookVertical = true;

				scene = new THREE.Scene();

				// sides

				var matrix = new THREE.Matrix4();

				var pxGeometry = new THREE.PlaneTypedGeometry( 100, 100 );
				pxGeometry.uvs[ 1 ] = 0.5;
				pxGeometry.uvs[ 3 ] = 0.5;
				pxGeometry.applyMatrix( matrix.makeRotationY( Math.PI / 2 ) );
				pxGeometry.applyMatrix( matrix.makeTranslation( 50, 0, 0 ) );

				var nxGeometry = new THREE.PlaneTypedGeometry( 100, 100 );
				nxGeometry.uvs[ 1 ] = 0.5;
				nxGeometry.uvs[ 3 ] = 0.5;
				nxGeometry.applyMatrix( matrix.makeRotationY( - Math.PI / 2 ) );
				nxGeometry.applyMatrix( matrix.makeTranslation( - 50, 0, 0 ) );

				var pyGeometry = new THREE.PlaneTypedGeometry( 100, 100 );
				pyGeometry.uvs[ 5 ] = 0.5;
				pyGeometry.uvs[ 7 ] = 0.5;
				pyGeometry.applyMatrix( matrix.makeRotationX( - Math.PI / 2 ) );
				pyGeometry.applyMatrix( matrix.makeTranslation( 0, 50, 0 ) );

				var pzGeometry = new THREE.PlaneTypedGeometry( 100, 100 );
				pzGeometry.uvs[ 1 ] = 0.5;
				pzGeometry.uvs[ 3 ] = 0.5;
				pzGeometry.applyMatrix( matrix.makeTranslation( 0, 0, 50 ) );

				var nzGeometry = new THREE.PlaneTypedGeometry( 100, 100 );
				nzGeometry.uvs[ 1 ] = 0.5;
				nzGeometry.uvs[ 3 ] = 0.5;
				nzGeometry.applyMatrix( matrix.makeRotationY( Math.PI ) );
				nzGeometry.applyMatrix( matrix.makeTranslation( 0, 0, -50 ) );

				//

				var geometry = new THREE.TypedGeometry( worldWidth * worldDepth * 2 * 5 ); // 2 triangles, 5 possible sides

				for ( var z = 0; z < worldDepth; z ++ ) {

					for ( var x = 0; x < worldWidth; x ++ ) {

						var h = getY( x, z );

						matrix.makeTranslation(
							x * 100 - worldHalfWidth * 100,
							h * 100,
							z * 100 - worldHalfDepth * 100
						);

						var px = getY( x + 1, z );
						var nx = getY( x - 1, z );
						var pz = getY( x, z + 1 );
						var nz = getY( x, z - 1 );

						geometry.merge( pyGeometry, matrix );

						if ( ( px != h && px != h + 1 ) || x == 0 ) {

							geometry.merge( pxGeometry, matrix );

						}

						if ( ( nx != h && nx != h + 1 ) || x == worldWidth - 1 ) {

							geometry.merge( nxGeometry, matrix );

						}

						if ( ( pz != h && pz != h + 1 ) || z == worldDepth - 1 ) {

							geometry.merge( pzGeometry, matrix );

						}

						if ( ( nz != h && nz != h + 1 ) || z == 0 ) {

							geometry.merge( nzGeometry, matrix );

						}

					}

				}

				geometry.computeBoundingSphere();

				var texture = THREE.ImageUtils.loadTexture( 'textures/minecraft/atlas.png' );
				texture.magFilter = THREE.NearestFilter;
				texture.minFilter = THREE.LinearMipMapLinearFilter;

				var mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { map: texture } ) );
				scene.add( mesh );

				var ambientLight = new THREE.AmbientLight( 0xcccccc );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
				directionalLight.position.set( 1, 1, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}

			function generateHeight( width, height ) {

				var data = [], perlin = new ImprovedNoise(),
				size = width * height, quality = 2, z = Math.random() * 100;

				for ( var j = 0; j < 4; j ++ ) {

					if ( j == 0 ) for ( var i = 0; i < size; i ++ ) data[ i ] = 0;

					for ( var i = 0; i < size; i ++ ) {

						var x = i % width, y = ( i / width ) | 0;
						data[ i ] += perlin.noise( x / quality, y / quality, z ) * quality;


					}

					quality *= 4

				}

				return data;

			}

			function getY( x, z ) {

				return ( data[ x + z * worldWidth ] * 0.2 ) | 0;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				controls.update( clock.getDelta() );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>